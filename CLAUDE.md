# 뱀파이어 서바이벌 단순화 게임 프로젝트

## 📋 프로젝트 개요

### 게임 컨셉

- **장르**: 뱀파이어 서바이벌 단순화 버전
- **플랫폼**: 웹 → Capacitor로 모바일 앱 변환
- **아트 스타일**: 기하학적 도형 (아트 부담 최소화)
- **개발 기간**: 4주 예상

### 핵심 게임플레이

- **플레이어 조작**: 이동만 (터치/마우스)
- **자동 공격**: 플레이어 주변 궤도 무기
- **목표**: 15분 생존
- **성장**: 레벨업 시 3가지 강화 중 선택

### 무기 시스템 (단순화)

- **궤도탄**: 플레이어 주변 도는 투사체
- **직선탄**: 플레이어에서 발사되는 투사체
- **방어막**: 플레이어 주변 보호막

### 메타 진행 시스템

- **클리어 시**: 유물 3개 중 1개 선택 획득
- **게임오버 시**: 유물 없음, 재시작만
- **난이도 증가**: 클리어할 때마다 적 스탯 +25%
- **유물 효과**: 영구적 능력 강화 (체력, 데미지, 속도 등)

## 📱 UI/UX 설계

### 모바일 우선 설계

- **화면 구성**: 상단 상태바 + 중앙 게임 영역 + 하단 버튼
- **기준 해상도**: 375px 너비 (모바일 표준)
- **데스크탑**: 모바일 크기 유지, 양쪽 여백 처리

### 화면별 구성

1. **인게임**: 상태바(HP, 레벨, 점수) + 게임 영역 + 조작 버튼
2. **레벨업**: 전체 화면 오버레이로 업그레이드 선택
3. **게임 클리어**: 결과 표시 + 유물 3개 중 선택
4. **게임오버**: 결과 표시 + 재시작/홈 버튼

### 터치 조작

- **이동**: 터치한 지점으로 플레이어 이동 (탭 투 무브)
- **UI 조작**: 충분한 크기의 터치 타겟 (44px 이상)
- **제스처**: 더블탭으로 일시정지

## 🔧 기술적 구현

### 개발 스택

- **프론트엔드**: React
- **그래픽**: pixiJS
- **상태 관리**: React useState/useReducer
- **모바일 변환**: Capacitor
- **저장**: LocalStorage

### 성능 고려사항

- **오브젝트 풀링**: 적/투사체 재사용으로 GC 부담 감소
- **프레임률 제한**: 30fps로 제한하여 배터리 절약
- **렌더링 최적화**: 화면 밖 오브젝트 렌더링 스킵

### 데이터 저장

- **게임 진행**: 클리어 횟수, 보유 유물, 난이도 배수
- **통계**: 최고 기록, 총 플레이 시간, 적 처치 수
- **설정**: 사운드, 진동 등 사용자 설정

## 📲 모바일 앱 변환 고려사항

### Capacitor 설정

- **안전 영역**: iOS 노치, Android 네비게이션 바 대응
- **성능 최적화**: WebView 성능 한계 고려
- **네이티브 기능**: 햅틱 피드백, 알림 활용

### 주요 이슈

1. **성능**: Canvas 게임의 WebView 성능 저하 (30-50%)
2. **터치 지연**: 300ms 지연 방지 설정 필요
3. **배터리**: 네이티브 대비 높은 배터리 소모
4. **앱스토어**: "웹 래퍼" 거부 위험, 네이티브 기능 필수

### 해결 방안

- **성능 프로파일링**: 실기기 테스트 필수
- **네이티브 기능 활용**: 햅틱, 푸시 알림 등 추가
- **최적화**: 불필요한 렌더링 제거, 메모리 관리

## 🗓 개발 일정

### 1주차: 기본 게임 구현

- 플레이어 이동 (터치 조작)
- 적 스폰 및 AI
- 자동 공격 시스템
- 충돌 감지

### 2주차: 게임 루프 완성

- 경험치 시스템
- 레벨업 및 업그레이드 선택
- 승리/패배 조건
- 기본 UI 구현

### 3주차: 메타 시스템

- 유물 시스템 (8-10개)
- 난이도 증가 메커니즘
- 데이터 저장/로드
- 게임 통계

### 4주차: 폴리싱 및 최적화

- 모바일 UI 최적화
- 성능 최적화
- Capacitor 변환 및 테스트
- 밸런싱 조정

## 🎯 핵심 설계 결정

### 단순화 선택

- **무기 3종류**: 복잡한 조합 대신 명확한 역할 분담
- **고정 목표**: 15분 생존 (뱀서의 30분보다 짧게)
- **기하학적 그래픽**: 아트 리소스 부담 제거
- **단일 맵**: 다양한 스테이지 대신 하나의 영역

### 재플레이 가치

- **유물 시스템**: 매 클리어마다 새로운 능력 획득
- **난이도 증가**: 점진적 도전 상승
- **선택의 재미**: 업그레이드와 유물 선택의 전략성

### 모바일 최적화

- **터치 친화적**: 조이스틱 대신 탭 투 무브
- **단순한 UI**: 최소한의 인터페이스 요소
- **성능 우선**: 화려함보다 안정성과 배터리 효율

## ⚠️ 주요 위험 요소

### 기술적 위험

1. **Canvas 성능**: 모바일에서 다수 오브젝트 처리 시 프레임 드롭
2. **Capacitor 한계**: WebView 성능 병목과 네이티브 기능 제약
3. **메모리 관리**: 장시간 플레이 시 메모리 누수 가능성

### 디자인 위험

1. **단순함의 지루함**: 너무 단순해서 금방 질릴 수 있음
2. **밸런싱**: 유물과 난이도 증가의 적절한 균형 찾기
3. **모바일 UX**: 터치 조작의 정확성과 편의성 확보

### 비즈니스 위험

1. **앱스토어 정책**: 웹 래퍼 앱의 승인 불확실성
2. **시장 경쟁**: 이미 포화된 생존 게임 시장
3. **수익화**: 단순한 게임의 수익 모델 한계

## 🎲 추가 고려사항

### 향후 확장 가능성

- **멀티플레이어**: 협동/경쟁 모드
- **시즌 콘텐츠**: 기간 한정 이벤트
- **커스터마이징**: 스킨, 이펙트 등
- **소셜 기능**: 리더보드, 업적 공유

### 수익화 옵션

- **광고**: 부활 시 광고 시청
- **프리미엄**: 광고 제거, 추가 유물
- **코스메틱**: 플레이어/무기 스킨
- **배틀패스**: 시즌별 진행 보상

## 📈 성공 지표

### 단기 목표 (출시 1개월)

- **사용자 유지율**: 1일 70%, 7일 30%
- **세션 길이**: 평균 10-15분
- **완주율**: 플레이어의 20% 이상이 첫 클리어

### 중기 목표 (출시 3개월)

- **월간 활성 사용자**: 1000명 이상
- **평균 세션**: 주당 5회 이상
- **수익화**: 월 수익 $100 이상 (광고/프리미엄)

이 프로젝트는 **단순함 속의 재미**와 **모바일 최적화**에 집중하여, 개발 부담을 최소화하면서도 중독성 있는 게임플레이를 제공하는 것을 목표로 합니다.

---

# 📋 구현 완료 현황 (업데이트됨)

## 🎯 **전체 진행률: 약 80% 완료**

### ✅ **Week 1-2: 핵심 게임플레이 완료 (100%)**

#### 🎮 **게임 엔진 & 핵심 시스템**
- **PixiJS 게임 엔진**: 완전 구현 (375x455 캔버스, React 통합)
- **게임 루프**: 15분 생존 목표, 일시정지/재개 기능
- **플레이어 시스템**: 터치/마우스 이동, 부드러운 애니메이션
- **적 AI 시스템**: 자동 스폰, 플레이어 추적, 화면 밖 제거

#### ⚔️ **전투 & 무기 시스템**
- **궤도탄 무기**: 플레이어 주변 회전하는 청록색 투사체
- **직선탄 무기**: 가장 가까운 적 자동 타겟팅 황색 투사체  
- **충돌 감지**: 원형 충돌 시스템, 정확한 히트박스
- **데미지 시스템**: 투사체 15 데미지, 적 30 체력

#### 📊 **경험치 & 레벨업**
- **경험치 드롭**: 적 처치 시 10 XP 획득
- **레벨업 계산**: 필요 경험치 20% 증가 (100 → 120 → 144...)
- **업그레이드 선택**: 5가지 강화 옵션 (궤도탄, 직선탄, 방어막, 체력, 속도)
- **레벨업 UI**: 전체 화면 모달, 게임 일시정지

#### 🎯 **충돌 & 데미지 시스템**
- **플레이어 데미지**: 레벨별 증가 (기본 10 + (레벨-1) × 0.5)
- **무적시간**: 1초 무적, 시각적 반투명 효과
- **게임오버**: 체력 0 시 자동 감지 및 처리
- **적 스폰 스케일링**: 5레벨마다 동시 스폰 수 +1 (1→2→3마리)

### ✅ **UI/UX 시스템 완료 (100%)**

#### 📱 **모바일 우선 인터페이스**
- **HUD 시스템**: 상태바, 체력바, 경험치바, 스킬 아이콘
- **메인 메뉴**: 게임 시작, 설정 버튼 (완전 기능)
- **레벨업 화면**: 5가지 업그레이드 선택 UI
- **게임오버 화면**: React Portal 사용, 결과 표시, 재도전/메인메뉴 버튼

#### 🎨 **반응형 디자인**
- **375px 기준**: 모바일 최적화 레이아웃
- **터치 최적화**: 44px+ 터치 타겟, 300ms 지연 방지
- **시각적 피드백**: 무적시간 반투명, 진행바 애니메이션

### ✅ **상태 관리 & 아키텍처 (100%)**

#### 🔄 **React 상태 관리**
- **GameStateContext**: useReducer 기반 중앙 상태 관리
- **실시간 동기화**: GameEngine ↔ React 상태 양방향 통신
- **액션 시스템**: 13개 게임 액션 타입 (시작, 일시정지, 레벨업, 데미지 등)

#### 🏗️ **코드 아키텍처**
```
src/
├── components/           # React UI 컴포넌트 (5개)
│   ├── GameCanvas.tsx   # PixiJS 통합 래퍼
│   ├── HUD.tsx          # 게임 상태 표시
│   ├── LevelUp.tsx      # 업그레이드 선택
│   ├── MainMenu.tsx     # 메인 메뉴
│   └── GameOver.tsx     # 패배 화면
├── contexts/             # 상태 관리
│   └── GameStateContext.tsx
├── game/                 # 게임 로직 (PixiJS)
│   ├── GameEngine.ts    # 메인 게임 엔진
│   ├── entities/        # 플레이어, 적 클래스
│   └── managers/        # 시스템 매니저들
└── App.tsx              # 메인 앱 구조
```

### ✅ **추가 완료 사항 (Week 3)**

#### 🔥 **난이도 스케일링 시스템**
- **완료**: 클리어 시 적 스탯 25% 증가 메커니즘
- **완료**: HUD에 난이도 레벨 표시 (🔥숫자)
- **완료**: 적 색상 변화로 난이도 시각화
- **완료**: 재시작 시 난이도 유지, 메인메뉴 이동 시 초기화

#### 🏆 **승리 화면 UI**
- **완료**: 15분 클리어 시 승리 화면 표시
- **완료**: 게임 결과 통계 (레벨, 점수, 시간)
- **완료**: 난이도 변화 표시 (이전 → 현재)
- **완료**: Continue/Main Menu 버튼

### ✅ **최근 완료된 주요 작업 (Gemini)**

#### 🛡️ **방어막 무기 시스템 (롤백 및 재구현)**
- **문제점**: 초기 방어막 구현 시 데미지 미적용 및 통계 누락 문제 발생. 회전 구체 형태로 변경 시도했으나, 기능 미작동 및 복잡도 증가로 롤백 결정.
- **해결**:
    - `GameStateContext.tsx`: `shield` 무기 타입을 `{ level, damage, radius, cooldown }`으로 재정의.
    - `WeaponManager.ts`:
        - 방어막을 단일 반투명 원(`PIXI.Graphics`)으로 구현.
        - `updateShield` 메서드는 시각적 업데이트 및 쿨다운 관리만 담당.
        - `getShieldDamageTargets()` 메서드를 추가하여, 방어막 범위 내의 적 목록을 반환하도록 변경.
    - `GameEngine.ts`:
        - `gameLoop`에서 `weaponManager.getShieldDamageTargets()`를 호출하여 데미지 대상 적 목록을 가져옴.
        - 가져온 적들에게 `handleDamageEvent()`를 통해 데미지를 적용하고 통계를 기록하도록 중앙화.
    - `LevelUp.tsx`: 방어막 업그레이드 시 `damage`, `radius`, `cooldown`이 증가하도록 로직 수정.
- **결과**: 방어막이 정상적으로 데미지를 입히고 통계에 반영됨.

#### 📊 **전투 통계 시스템 구축**
- **목표**: 게임 승리 시 "적 처치 수, 경험치, 무기별 처치 수, 최대 데미지를 낸 무기와 최대 데미지"를 표시.
- **구현**:
    - `GameStateContext.tsx`:
        - `GameStats` 인터페이스 정의 (`enemiesKilled`, `experienceGained`, `damageDealt`, `weaponStats`, `highestDamage`).
        - `GameState`에 `stats: GameStats` 속성 추가 및 초기화 로직 구현.
        - `UPDATE_STATS` 액션 타입 추가 및 리듀서 로직 구현.
    - `GameEngine.ts`:
        - `handleDamageEvent()` 메서드를 중앙 데미지 처리 및 통계 기록 함수로 리팩토링.
        - 적 처치 및 데미지 발생 시 `UPDATE_STATS` 액션을 `dispatch`하여 통계 업데이트.
    - `Victory.tsx`: `GameState`의 `stats` 데이터를 활용하여 승리 화면에 상세 전투 통계 표시.
- **결과**: 게임 승리 시 상세한 전투 통계가 정상적으로 표시됨.

#### 🔄 **플레이어 체력/경험치 업데이트 문제 해결**
- **문제점**: 통계 시스템 도입 후 플레이어 체력 및 경험치 업데이트가 고정되거나 누락되는 현상 발생.
- **원인**: 여러 `dispatch` 호출이 한 프레임 내에서 충돌하여 상태 업데이트가 덮어쓰여짐.
- **해결**:
    - `GameEngine.ts`:
        - 플레이어 체력 업데이트를 `gameLoop`의 `UPDATE_PLAYER` 액션에 통합.
        - 적 처치 시 경험치/점수 `dispatch`를 제거하고, 모든 통계 관련 업데이트를 `UPDATE_STATS` 액션으로 통일.
    - `GameStateContext.tsx`: `UPDATE_STATS` 리듀서에서 통계뿐만 아니라 경험치 및 점수 증가, 레벨업 처리까지 모두 담당하도록 로직 통합.
- **결과**: 플레이어 체력 및 경험치가 실시간으로 정확하게 업데이트됨.

#### 👾 **적 겹침 및 충돌 문제 해결**
- **문제점**: 적들이 한 점에 겹쳐서 자동 공격이 인식하지 못하고, 플레이어 피격이 제대로 되지 않으며, 새로운 적 스폰이 멈추는 문제 발생.
- **원인**: 적들이 서로의 위치를 고려하지 않고 플레이어만 추적하여 겹침 현상 발생. 플레이어 피격 로직이 무적 시간 동안 모든 충돌을 무시하여 데미지 누락.
- **해결**:
    - `Enemy.ts`:
        - `update` 메서드에 `otherEnemies` 인자를 추가하여 다른 적들과의 **분리(Separation) 로직** 구현. (서로 겹치지 않도록 밀어내는 힘 적용)
        - `isInvincible()` 메서드를 추가하여 플레이어의 무적 상태를 외부에 노출.
    - `EnemyManager.ts`:
        - `update` 메서드에서 각 적의 `update` 호출 시, 해당 적을 제외한 `allEnemies` 배열을 전달.
    - `GameEngine.ts`:
        - `handleCollisions`에서 플레이어 피격 로직을 수정. `collisions.playerEnemyCollisions`가 존재하고 플레이어가 무적 상태가 아닐 때만 **단 한 번** 데미지를 적용하도록 변경.
- **결과**: 적들이 더 이상 겹치지 않고 자연스럽게 퍼지며, 플레이어 피격이 무적 시간과 연동되어 정확하게 작동함.

#### ♻️ **적 클래스 리팩토링 및 '추적자' 구현 (1단계)**
- **목표**: 다양한 적 타입을 유연하게 추가할 수 있는 구조 마련 및 '추적자' 적 구현.
- **구현**:
    - `src/game/entities/behaviors` 폴더 신설.
    - `IEnemyBehavior.ts` 인터페이스 정의 (적 행동 패턴의 계약).
    - `Enemy.ts` 리팩토링:
        - `EnemyType` enum 추가 (`Basic`, `Chaser`, `Giant`, `Sniper`).
        - 생성자에서 `EnemyType`과 `IEnemyBehavior`를 주입받도록 변경.
        - `createSprite` 메서드를 적 타입에 따라 다른 모양과 색상을 그리도록 수정.
        - `update` 메서드가 주입된 `behavior.update()`를 호출하도록 위임.
        - `setPosition`, `getSpeed` 등 필요한 getter/setter 추가.
    - `BasicChaserBehavior.ts` 구현: 기존의 플레이어 추적 및 적 분리 로직을 이 클래스로 이동.
    - `EnemyManager.ts`:
        - `update` 메서드에서 `gameTime`을 받아 `getEnemyTypeForCurrentTime()`을 통해 현재 시간에 맞는 적 타입을 결정.
        - `getBehaviorForType()`을 통해 해당 타입에 맞는 `IEnemyBehavior` 인스턴스를 반환.
        - `Enemy` 생성 시 새로운 생성자 시그니처에 맞춰 `EnemyType`과 `behavior`를 전달.
- **결과**: 새로운 적 타입을 쉽게 추가할 수 있는 확장성 있는 구조가 마련되었으며, 게임 시간에 따라 '추적자' 적이 정상적으로 스폰됨.

#### 👾 **새로운 적 타입 구현 (2단계: 거인, 3단계: 저격수)**
- **목표**: `enemy_basic.md`에 명시된 '거인'과 '저격수' 적을 구현하고 게임에 통합.
- **구현**:
    - **거인 (Giant)**:
        - `GiantBehavior.ts` 구현: `BasicChaserBehavior`를 상속받아 느린 추적 행동 구현.
        - `EnemyManager.ts`:
            - `getEnemyTypeForCurrentTime()`에 `EnemyType.Giant` 스폰 확률 추가 (게임 시간 2분부터).
            - `getBehaviorForType()`에서 `EnemyType.Giant`에 `GiantBehavior` 반환.
            - `removeEnemy()` 메서드에 거인(`EnemyType.Giant`) 사망 시 `spawnSplitEnemies()` 호출 로직 추가.
            - `spawnSplitEnemies()` 구현: 거인 사망 위치에 `EnemyType.Basic` 적들을 여러 마리(게임 시간에 따라 증가) 생성하여 퍼뜨림.
    - **저격수 (Sniper)**:
        - `SniperBehavior.ts` 구현: `IEnemyBehavior`를 구현하여 플레이어와 거리 유지 및 원거리 공격 로직 포함.
        - `WeaponManager.ts`:
            - `Projectile` 인터페이스에 `isEnemyProjectile` 속성 추가.
            - `fireEnemyProjectile()` 메서드 추가: 적이 투사체를 발사할 수 있도록 구현 (색상, 크기 다르게).
            - `createProjectile()` 수정: `isEnemyProjectile` 인자를 받아 적 투사체 생성 로직 포함.
        - `CollisionManager.ts`:
            - `CollisionResult`에 `enemyProjectilePlayerCollisions` 추가.
            - `checkCollisions()` 수정: 적 투사체와 플레이어 간의 충돌을 감지하여 `enemyProjectilePlayerCollisions`에 추가.
        - `GameEngine.ts`:
            - `gameLoop`에서 `weaponManager.fireProjectiles()` 호출 시 `enemies` 인자 전달.
            - `handleCollisions()` 수정: `enemyProjectilePlayerCollisions`를 순회하며 플레이어에게 데미지 적용 및 투사체 제거.
        - `EnemyManager.ts`:
            - 생성자에서 `WeaponManager` 인스턴스를 주입받도록 변경.
            - `EnemyUpdateContext`에 `weaponManager`와 `stage`를 추가하여 `SniperBehavior`에서 접근 가능하도록 함.
            - `getEnemyTypeForCurrentTime()`에 `EnemyType.Sniper` 스폰 확률 추가 (게임 시간 5분부터).
            - `getBehaviorForType()`에서 `EnemyType.Sniper`에 `SniperBehavior` 반환.
- **결과**: '거인'과 '저격수' 적이 게임에 성공적으로 통합되었으며, 각자의 행동 패턴(분열, 원거리 공격)을 정상적으로 수행함.

#### 🎁 유물 시스템 구현 및 관련 버그 수정
- **목표**: 게임의 핵심 재플레이 요소인 '유물' 시스템을 구현하고, 이 과정에서 발생한 다양한 버그를 해결하여 유물 효과가 정상적으로 누적 적용되도록 함.
- **구현**:
    - **데이터 정의 및 저장**:
        - `src/data/artifacts.ts`: 모든 유물의 ID, 이름, 설명, 효과(합연산/곱연산, 적용 능력치 경로)를 정의하는 중앙 데이터베이스 구축.
        - `src/utils/storage.ts`: 플레이어가 획득한 유물 ID 목록을 `LocalStorage`에 저장하고 불러오는 유틸리티 함수 구현.
    - **상태 관리 통합**:
        - `src/contexts/GameStateContext.tsx`:
            - `GameState` 인터페이스에 `ownedArtifacts: ArtifactID[]` 속성 추가 및 `player.speed` 속성 추가.
            - `initialState`에서 `loadOwnedArtifacts()`를 통해 보유 유물 목록을 초기화.
            - **`START_NEW_ROUND` 액션 도입**: 유물 획득(`newArtifactId`)과 다음 라운드 시작을 하나의 원자적 액션으로 통합. 이 리듀서는 `initialState`를 기반으로 라운드별 초기화가 필요한 속성(`score`, `time`, `stats` 등)만 리셋하고, `ownedArtifacts`, `difficulty`, `player`, `weapons` 등 **유물 효과로 강화된 능력치들은 이전 라운드의 상태를 유지**하도록 로직을 개선.
            - `applyArtifacts` 함수를 리듀서 내부에서 호출하여, 유물 효과가 적용된 최종 `GameState`를 직접 반환하도록 하여 `GameState` 자체가 항상 "진실의 원천"이 되도록 함.
    - **유물 효과 적용 로직**:
        - `src/game/systems/ArtifactSystem.ts`: `applyArtifacts` 함수 구현. `GameState`와 `ownedArtifacts`를 받아, 유물 효과(합연산/곱연산)를 순서대로 적용하여 강화된 `GameState`를 반환. 특히 `stat` 경로의 깊이(`player.speed` vs `weapons.projectile.damage`)를 정확히 파악하여 해당 능력치에 값을 적용하도록 개선.
    - **게임 엔진 연동**:
        - `src/components/GameCanvas.tsx`: `state.isPlaying` 상태 변화 시 `applyArtifacts`를 호출하여 유물 효과가 적용된 `finalState`를 계산하고, `gameEngine.restart(finalState)`를 호출하여 엔진을 초기화하고 새로운 상태를 반영.
        - `src/game/GameEngine.ts`:
            - `start(initialState)` 및 `restart(initialState)` 메서드가 유물 효과가 적용된 `GameState`를 받아 엔진 내부의 플레이어(`this.player.speed`, `this.player.maxHealth`) 및 무기 관련 속성들을 업데이트하도록 수정.
            - `updateFromGameState` 메서드에서 `GameState`의 플레이어 및 무기 속성을 `GameEngine` 내부 속성에 정확히 반영하도록 로직 개선.
    - **UI 및 기타 수정**:
        - `src/components/Victory.tsx`: 승리 화면에서 유물 선택 UI를 `ui_layout.md`에 명시된 카드 형태로 표시되도록 스타일 수정. 유물 선택 시 `START_NEW_ROUND` 액션을 디스패치하도록 변경.
        - `src/components/GameOver.tsx`: 게임 오버 후 재시작 시 `START_NEW_ROUND` 액션을 사용하도록 변경.
        - `src/index.css`: Tailwind CSS 클래스들이 정상적으로 적용되도록 `@tailwind` 지시문 추가.
        - `src/game/entities/Player.ts`: `Player` 클래스에 `public speed` 및 `public maxHealth` 속성 추가.
        - `src/game/managers/WeaponManager.ts`: `OrbitalWeaponInstance` 인터페이스 도입 및 `orbitalWeapons` 배열 타입 변경, `addOrbitalWeapon` 메서드에 `damage` 인자 추가, `updateWeaponStats`에서 모든 무기 속성을 `GameState`에 따라 업데이트하도록 로직 확장.
- **결과**:
    - 유물 효과가 매 라운드마다 정상적으로 누적 적용됨 (예: 직선탄 데미지 `15 -> 18.75 -> 20.625`).
    - 난이도 증가 메커니즘이 정상적으로 작동하여 다음 라운드에 반영됨.
    - 승리 화면의 유물 선택 UI가 의도한 대로 카드 형태로 표시됨.
    - 게임 재시작 시 무한 루프 및 상태 초기화 문제가 해결됨.
    - 이 과정에서 발생했던 수많은 타입스크립트 및 문법 오류들이 해결되어 코드의 안정성이 향상됨.

### ❌ **미구현 사항 (추후 개발)**

#### 🔧 **업그레이드 효과 연동 (부분 완료)**
- **문제점**: 일부 업그레이드 효과(예: 플레이어 이동 속도 증가)가 UI에만 반영되고 실제 게임플레이에 적용되지 않음.
- **구현 필요**: `LevelUp.tsx`에서 선택된 업그레이드가 `Player` 클래스 또는 관련 매니저에 실제 능력치 변화를 적용하도록 연동.

#### 🎁 **유물 시스템**
- **목표**: 게임의 핵심 재플레이 요소인 '유물' 시스템 구현.
- **구현 필요**:
    - 유물 데이터 정의 (8-10개 유물).
    - 유물 효과 구현 및 적용 (영구적 능력 강화).
    - 승리 시 유물 3개 중 하나를 선택하는 UI 및 로직 구현.
    - 유물 보관함 UI.

#### 💾 **데이터 저장 시스템**
- **목표**: 게임 진행 데이터(클리어 횟수, 보유 유물) 및 통계 데이터(최고 기록, 플레이 시간) 영구 저장.
- **구현 필요**: `LocalStorage` 기반 저장/로드 시스템.

#### 📱 **모바일 앱 변환**
- **목표**: Capacitor를 사용하여 웹 게임을 모바일 앱으로 변환.
- **구현 필요**:
    - Capacitor 프로젝트 설정 및 빌드.
    - 네이티브 기능(햅틱 피드백 등) 연동.
    - WebView 환경에서의 성능 최적화 (30fps 제한, 오브젝트 풀링 등).

#### 🎨 **폴리싱 및 밸런싱**
- **목표**: 게임의 완성도와 사용자 경험 향상.
- **구현 필요**:
    - 승리 화면 고도화 (애니메이션, 파티클, 사운드).
    - 전반적인 게임 밸런싱 조정 (적 스폰, 무기 데미지, 레벨업 곡선 등).
    - 사운드 시스템 추가.
    - 추가적인 시각적 피드백 (예: 적 피격 이펙트).

이 문서는 프로젝트의 현재 상태와 향후 계획을 정확히 반영하며, 개발 진행상황을 실시간으로 추적할 수 있도록 구성되었습니다.
